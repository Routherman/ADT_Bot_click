Plan de Implementaci√≥n para nav_Enriquecer.py
Descripci√≥n General

El script nav_Enriquecer.py corresponde a la etapa 3 del proceso y tiene como objetivo enriquecer los correos electr√≥nicos de contactos clave (p. ej. personal de marketing, planificaci√≥n de eventos, etc.) utilizando las plataformas Lusha, ContactOut y RocketReach. Se trata de una aplicaci√≥n Streamlit que leer√° los resultados de las etapas 1 y 2, filtrar√° los dominios candidatos seg√∫n un puntaje m√≠nimo (definido en .env), mostrar√° visualmente los dominios aptos y permitir√° al usuario seleccionar uno, varios o todos para buscar contactos en las plataformas mencionadas. Los nuevos datos enriquecidos se guardar√°n en un archivo JSON incremental, y se llevar√° un registro (log) para evitar consultas repetidas innecesarias.

Datos de Entrada y Configuraci√≥n

Archivos de etapas previas: El script leer√° los archivos de salida de la etapa 1 y etapa 2. Estos pueden incluir CSV/JSON con listas de dominios, informaci√≥n de contactos (persons.csv, emails.csv, etc.) u otros datos estructurados. Por ejemplo:

Una lista de dominios (sitios web de venues o empresas relevantes).

Informaci√≥n recopilada de cada dominio: nombres de personas, cargos/roles (marketing, eventos, etc.), correos generales encontrados, tel√©fonos, redes sociales, etc.

Archivo de configuraci√≥n .env: Contendr√° variables necesarias, tales como:

Puntaje m√≠nimo de dominio para filtrar qu√© dominios son aptos para enriquecimiento (por ejemplo, una puntuaci√≥n de reputaci√≥n o relevancia obtenida en etapa 2). El script debe leer este valor (ej. DOMAIN_SCORE_MIN) usando una biblioteca como python-dotenv.

Credenciales/API keys para Lusha, ContactOut, RocketReach. Estas plataformas requieren claves de API o tokens de acceso para realizar consultas de b√∫squeda de emails. Las variables podr√≠an ser algo como LUSHA_API_KEY, ROCKETREACH_API_KEY, CONTACTOUT_API_KEY.

Diccionario de roles (Opcional): Si existe un archivo (ej. roles_dictionary.json) con palabras clave o categor√≠as de roles (marketing, events, booking, etc.), se puede usar para identificar qu√© cargos son relevantes al buscar contactos. Esto ayudar√° a filtrar personas de inter√©s en cada empresa.

Nota: Es fundamental cargar la configuraci√≥n antes de nada. Ejemplo de lectura de .env:

from dotenv import load_dotenv
import os

load_dotenv()
MIN_SCORE = int(os.getenv("DOMAIN_SCORE_MIN", 0))
LUSHA_KEY = os.getenv("LUSHA_API_KEY")
# ... y as√≠ con las dem√°s claves

Interfaz de Usuario con Streamlit

Usaremos Streamlit para crear una interfaz interactiva que permita visualizar los dominios y seleccionar cu√°les enriquecer. Aspectos a implementar:

T√≠tulo y descripci√≥n: Mostrar un t√≠tulo claro (ej. "Enriquecimiento de Contactos ‚Äì Etapa 3") y una breve descripci√≥n de la funcionalidad.

Listado de dominios aptos: Presentar en la app una lista de dominios filtrados por el puntaje m√≠nimo. Cada dominio mostrado deber√≠a haber superado el umbral MIN_SCORE obtenido del .env.

Si se tiene informaci√≥n adicional de cada dominio (ej. nombre de la empresa, puntaje, n√∫mero de posibles contactos encontrados en etapas previas), se puede mostrar junto al dominio para ayudar al usuario a decidir. Por ejemplo, una tabla con columnas: Dominio, Nombre Empresa, Score, Contactos Encontrados.

Selecci√≥n m√∫ltiple: Permitir al usuario seleccionar uno, varios o todos los dominios listados para procesar. Esto se puede hacer de varias formas en Streamlit:

Con un control de selecci√≥n m√∫ltiple (st.multiselect) que liste los dominios aptos. El usuario puede marcar uno o m√°s.

O con una serie de checkboxes generadas din√°micamente, una por dominio (aunque si la lista es muy larga, st.multiselect es m√°s conveniente).

Tambi√©n se puede incluir un bot√≥n global "Seleccionar todos" para marcar r√°pidamente todos los dominios aptos.

Buscador/filtrado: Incluir un campo de b√∫squeda (st.text_input) que permita filtrar la lista de dominios o buscar por nombre de persona:

Si el usuario escribe un texto, filtrar din√°micamente los dominios mostrados para coincidir con ese texto (ya sea en el nombre del dominio, nombre de la empresa o nombres de personas asociados).

Esto facilita encontrar un dominio espec√≠fico o verificar si cierta persona est√° asociada a alguno de los dominios.

Bot√≥n de enriquecimiento: Un bot√≥n de acci√≥n (por ejemplo, "üîç Enriquecer contactos seleccionados") que, al pulsarlo, dispara el proceso de b√∫squeda de contactos en las plataformas para los dominios seleccionados.

Ejemplo de configuraci√≥n de UI en Streamlit:

import streamlit as st

st.title("Enriquecimiento de Contactos - Etapa 3")
st.write("Seleccione los dominios para buscar contactos clave (marketing, eventos, etc.) utilizando Lusha, ContactOut, RocketReach.")

# Campo de b√∫squeda
search_query = st.text_input("Filtrar dominios o personas:", "")

# Filtrar la lista de dominios aptos seg√∫n el texto de b√∫squeda
filtered_domains = [dom for dom in dominios_aptos if search_query.lower() in dom.lower() or search_query.lower() in nombre_empresa_de(dom).lower()]
# Mostrar lista seleccionable
selected_domains = st.multiselect("Dominios aptos para enriquecer:", options=filtered_domains, default=filtered_domains if seleccionar_todos else [])
# Bot√≥n para ejecutar enriquecimiento
if st.button("Enriquecer contactos seleccionados"):
    enriquecer_contactos(selected_domains)


(En el c√≥digo anterior, dominios_aptos es la lista de dominios filtrados por puntaje, y nombre_empresa_de(dom) hipot√©ticamente obtiene el nombre de la empresa asociada al dominio; seleccionar_todos podr√≠a ser un booleano controlado por otro checkbox.)

Filtrado de Dominios Aptos por Puntaje

Antes de mostrar los dominios en la interfaz, el script debe:

Cargar los datos de entrada (etapa 1 y 2): Esto puede implicar leer uno o varios archivos CSV/JSON con los resultados anteriores. Por ejemplo, si hay un extract.json consolidado con datos por dominio, ser√≠a ideal. En ausencia de un solo JSON, se pueden combinar varios CSV (persons, emails, etc.) en una estructura en memoria (por ejemplo, un dict o DataFrame) donde la clave principal sea el dominio o empresa.

Calcular o extraer el puntaje de cada dominio: Posiblemente en la etapa 2 se haya calculado un ‚Äúscore‚Äù o se tenga un criterio para cada dominio (por ejemplo, un ranking de relevancia, tr√°fico, etc.). Ese valor debe ser comparado con MIN_SCORE de .env. Si el puntaje no est√° directamente en los datos, quiz√°s se necesite calcularlo o leerlo de un campo espec√≠fico.

Filtrar la lista: Crear la lista dominios_aptos que incluya solo aquellos dominios cuyo puntaje ‚â• MIN_SCORE. Ignorar o excluir dominios con puntaje inferior.

Verificar informaci√≥n necesaria: Opcionalmente, se puede refinar a√∫n m√°s: incluir solo dominios que tengan suficiente informaci√≥n para iniciar la b√∫squeda en las plataformas. Por ejemplo, dominios que ya tengan nombres de personas y roles identificados (p. ej. encontramos un gerente de marketing en ese dominio durante la etapa 1). Las plataformas de enriquecimiento funcionan mejor si se les da al menos nombre, empresa y/o dominio, y a veces el cargo. Si un dominio no tiene ning√∫n nombre de persona asociado de etapas previas, igualmente podr√≠amos intentar buscar en RocketReach por empresa y un cargo gen√©rico (como "marketing" o "event planner"), pero los resultados podr√≠an ser menos focalizados.

Una estrategia es: si el dataset de etapa 1/2 proporciona nombres de personal por dominio, usar esos nombres; si no, usar las APIs para buscar empleados por cargo y empresa.

Mostrar conteo: En la interfaz, se puede indicar ‚ÄúN dominios aptos para enriquecer‚Äù para dar contexto. Cada dominio en la lista podr√≠a tener tambi√©n un indicador del n√∫mero de personas o contactos ya conocidos (por ejemplo: example.com (3 personas identificadas)).

B√∫squeda y Selecci√≥n de Dominios/Personas

La funcionalidad de b√∫squeda en la interfaz debe permitir al usuario filtrar por:

Nombre de dominio (ej: "example.com").

Nombre de la empresa asociada al dominio (si ese dato est√° disponible).

Nombre de personas identificadas en ese dominio o quiz√°s cargo.

Por ejemplo, si el usuario escribe "John" o "Marketing", la lista de dominios podr√≠a filtrarse a aquellos donde haya alguna persona que se llame John o cuyo cargo contenga "Marketing". Esto implica que tenemos accesible en memoria la informaci√≥n de personas/cargos por dominio para chequear contra la query de b√∫squeda.

Implementaci√≥n sugerida: Mantener en una estructura (como un dict o DataFrame) la informaci√≥n consolidada por dominio, incluyendo un listado de nombres y cargos. As√≠, al filtrar:

def cumple_filtro(dominio, query):
    data = data_por_dominio[dominio]
    # Revisar dominio y empresa
    if query.lower() in dominio.lower() or query.lower() in data["empresa"].lower():
        return True
    # Revisar personas
    for persona in data["personas"]:  # persona podr√≠a ser dict con 'nombre' y 'cargo'
        if query.lower() in persona["nombre"].lower() or query.lower() in persona["cargo"].lower():
            return True
    return False

filtered_domains = [dom for dom in dominios_aptos if cumple_filtro(dom, search_query)]


Luego filtered_domains se usa en st.multiselect como opciones.

Enriquecimiento de Contactos (Integraci√≥n con APIs)

Cuando el usuario confirma la selecci√≥n (al hacer clic en el bot√≥n de "Enriquecer"), el script debe iterar por cada dominio seleccionado y para cada uno realizar las siguientes acciones:

Evitar duplicados: Verificar en el archivo JSON de salida (/out/enriquecidos.json) o en un log si ese dominio ya fue procesado previamente. Si ya existen datos enriquecidos para ese dominio (o un registro de que se intent√≥ sin √©xito), se puede omitir o al menos advertir al usuario para no gastar consultas API innecesarias.

Preparar consultas a plataformas: Para cada dominio:

Reunir la informaci√≥n necesaria para las consultas: t√≠picamente el nombre de la empresa (si se tiene), el dominio (muchas APIs permiten buscar por dominio para listar empleados), y potencialmente nombres de personas y sus roles ya obtenidos.

Lusha: si tiene API disponible, suele requerir como entrada un nombre + empresa, o al menos un dominio para buscar personas relacionadas. Puede ser √∫til si tenemos nombres espec√≠ficos: por ejemplo, "Juan P√©rez en Empresa X" para obtener su email personal. Si no hay nombres, puede que Lusha no sea tan √∫til directamente.

RocketReach: proporciona una API donde se puede buscar por empresa (o dominio) y t√≠tulo de trabajo. Se puede usar para consultar, por ejemplo: company = X, title contains "marketing". RocketReach podr√≠a devolver una lista de personas (nombre, puesto, emails, etc.) que coinciden con ese criterio. Tambi√©n permite b√∫squeda por nombre + empresa directamente.

ContactOut: ofrece herramientas similares de enriquecimiento de perfiles (posiblemente a trav√©s de extensiones o API privadas). Si se dispone de acceso API, se podr√≠a usar de manera an√°loga a Lusha. De lo contrario, puede omitirse o usarse de forma manual.

Otras estrategias: Si alguna plataforma no cuenta con API p√∫blica, considerar usar su servicio a trav√©s de un wrapper o skippear su uso en la automatizaci√≥n.

B√∫squeda de contactos relevantes: Para enfocar en roles id√≥neos (marketing, event planning, etc.):

Definir una lista de palabras clave de cargos relevantes, por ejemplo: roles_busqueda = ["marketing", "event", "evento", "planner", "booking", "entertainment", "director", "manager"].

Usar esas palabras clave en las consultas de RocketReach (ej: t√≠tulo contiene "Event") o filtrar resultados de Lusha/ContactOut.

Si ya tenemos nombres de personas y sus cargos de etapas previas, priorizar buscar los emails de esas personas espec√≠ficas. Ejemplo: si en data_por_dominio["theatreX.com"] tenemos persona "Alice Smith ‚Äì Marketing Director", entonces consultar directamente a la API para "Alice Smith at theatreX.com" o "Alice Smith at Theatre X Company". Esto suele retornar su email personal (corporativo o incluso personal) si est√° disponible en la base de datos de la plataforma.

Si no tenemos nombres, entonces usar b√∫squeda gen√©rica: ‚Äúpersonas de marketing en Empresa X‚Äù. RocketReach API permite buscar con par√°metros company y title, devolviendo varios contactos potenciales. En tal caso, es importante filtrar luego cuales de esos t√≠tulos son relevantes (por ej., descartar si alguien es de IT o finanzas, etc., quedarnos con marketing, events).

Llamadas a la API: Implementar la comunicaci√≥n con cada servicio:

Cada plataforma tendr√° su endpoint y formato. Por ejemplo, RocketReach: https://api.rocketreach.co/v1/api/lookupProfile?api_key=YOUR_API_KEY&name=...&company=... (para b√∫squeda por nombre, o usar /search endpoint para b√∫squeda por compa√±√≠a/t√≠tulo). Se debe consultar la documentaci√≥n oficial para el formato exacto y campos de respuesta.

Incluir en el c√≥digo manejo de errores y l√≠mites: estas APIs suelen tener l√≠mites de rate o cr√©ditos, por lo que hay que controlar cu√°ntas consultas se hacen (quiz√°s pausar o lote por lote si son muchas). Tambi√©n manejar excepciones de red o casos donde no se encuentra ning√∫n resultado.

Es posible que no todas las plataformas necesiten usarse para cada dominio; podr√≠a usarse una preferida (ej: RocketReach) como primaria, y quiz√° Lusha/ContactOut para complementar o verificar datos.

Procesamiento de resultados: Una vez obtenidos los datos de contactos de la API:

Extraer nombre, apellido, cargo, correo electr√≥nico (y cualquier otro dato √∫til como tel√©fono, LinkedIn URL, etc.) de la respuesta.

Estructurarlo en un diccionario u objeto por persona. Ejemplo:

nuevo_contacto = {
    "nombre": first_name + " " + last_name,
    "cargo": title,
    "email": email,
    "fuente": "RocketReach",
    "linkedin": profile_url,
    ...
}


Agregar el contacto a la lista de contactos de ese dominio en la estructura de resultados acumulados.

Si el mismo contacto ya exist√≠a (por nombre/email) en nuestra base, evitar duplicados.

Opcional: Marcar qu√© plataforma proporcion√≥ cada contacto (por trazabilidad).

Feedback al usuario: Durante este proceso, la interfaz Streamlit deber√≠a informar al usuario del progreso. Por ejemplo, mostrar en tiempo real qu√© dominio se est√° procesando actualmente, cu√°ntos contactos nuevos se encontraron, o mensajes de ‚ÄúNo se encontraron contactos para X‚Äù. Esto se puede lograr con st.write o st.status updates, y si el proceso es largo, quiz√° usar st.progress o dividir en pasos para no bloquear la UI.

Guardado de Resultados en enriquecidos.json

Al finalizar (o a medida que se van procesando cada dominio), el script debe guardar los datos enriquecidos en un archivo JSON, situado en out/enriquecidos.json. Caracter√≠sticas de este archivo:

Estructura: Usar el dominio como clave principal. Por ejemplo:

{
  "theatreX.com": {
     "empresa": "Teatro X",
     "score": 85,
     "contactos": [
        {
          "nombre": "Alice Smith",
          "cargo": "Marketing Director",
          "email": "asmith@theatrex.com",
          "linkedin": "https://.../alice-smith",
          "fuente": "RocketReach"
        },
        {
          "nombre": "Bob Jones",
          "cargo": "Events Manager",
          "email": "bjones@theatrex.com",
          "linkedin": "https://.../bob-jones",
          "fuente": "Lusha"
        }
     ]
  },
  "otrodominio.com": { ... }
}


Guardar incremental: Es muy importante no sobrescribir todo el JSON cada vez, sino actualizarlo incrementalmente para no perder informaci√≥n ya obtenida. Esto implica:

Leer el JSON existente (si existe) al inicio del proceso de enriquecimiento.

Actualizar o a√±adir las entradas nuevas. Si un dominio ya tiene contactos guardados, agregar solo los nuevos contactos que no est√©n ya registrados.

Despu√©s de procesar todos los seleccionados (o uno por uno tras procesar cada dominio), escribir el JSON de nuevo a disco. Se puede usar json.dump con indentaci√≥n para legibilidad.

Asegurarse de manejar la concurrencia (en caso de que dos ejecuciones paralelas pudieran ocurrir, aunque con Streamlit probablemente se ejecuta una a la vez).

Formato consistente: Siempre utilizar el dominio como clave para facilitar b√∫squedas posteriores. Mantener los datos relevantes como en el ejemplo (empresa, score, lista de contactos con sus detalles). Si hay otros campos √∫tiles de etapas anteriores (por ej. direcci√≥n, tel√©fono de la empresa), tambi√©n se podr√≠an incluir bajo cada dominio para referencia completa.

Registro (Log) de Consultas Realizadas

Para no volver a ejecutar la misma consulta innecesariamente en el futuro, implementaremos un mecanismo de log. Esto previene gastar cr√©ditos de API buscando contactos que ya obtuvimos o intentar en dominios donde no hab√≠a nada disponible. Opciones a considerar:

Archivo de log separado: Crear un archivo (por ejemplo, out/enriquecidos.log o out/enriquecidos_history.csv) donde se a√±ade una l√≠nea o entrada por cada dominio procesado, con detalles b√°sicos (dominio, fecha/hora de consulta, n√∫mero de contactos encontrados, plataformas utilizadas, etc.).

Cada vez que se procesa un dominio, escribir en el log. Si se intenta procesar un dominio ya presente en el log, el script podr√≠a saltarlo autom√°ticamente o pedir confirmaci√≥n al usuario (por si se quiere forzar una actualizaci√≥n).

El log puede ser √∫til tambi√©n para depuraci√≥n, para ver si alguna consulta fall√≥ o cu√°ntos resultados se obtuvieron en cada plataforma.

Uso del JSON como log: Alternativamente, se puede inferir del enriquecidos.json qu√© dominios ya tienen datos. Si un dominio clave existe en el JSON (o existe pero con contactos vac√≠os, se√±al de intento fallido), eso se usa como indicador de que ya se intent√≥. Por simplicidad, se puede optar por esta v√≠a:

Antes de enriquecer un dominio, chequear if dominio in enriquecidos_data:; si existe y ya tiene contactos, omitir (o notificar que ya est√° hecho). Si existe pero la lista de contactos est√° vac√≠a o tiene flag "no data", podr√≠a significar que en una ejecuci√≥n previa no se encontr√≥ nada ‚Äî en ese caso, podr√≠amos saltarlo tambi√©n para evitar el mismo resultado, a menos que tengamos razones para intentar de nuevo con otra plataforma.

Interacci√≥n con usuario respecto a duplicados: Podr√≠a a√±adirse en la UI una opci√≥n tipo "Reintentar dominios ya procesados" por si se desea actualizar datos (por ejemplo, si se agregaron nuevas personas en las plataformas, o se consiguieron cr√©ditos adicionales luego). De lo contrario, por defecto el script evitar√° repetir.

Implementaci√≥n del log b√°sico:

# Supongamos enriquecidos_data es el dict cargado desde enriquecidos.json
procesados = set(enriquecidos_data.keys())  # conjunto de dominios ya en JSON

for dom in selected_domains:
    if dom in procesados:
        st.write(f"‚ö†Ô∏è Dominio {dom} ya procesado previamente, se omite para evitar duplicados.")
        continue
    # ... proceder a enriquecer dom si no estaba procesado
    # luego de obtener resultados:
    enriquecidos_data[dom] = info_contactos_dom
    procesados.add(dom)
    # opcional: escribir una entrada en enriquecidos.log


Al final, escribir de nuevo el JSON actualizado al archivo.

Resumen de Pasos para Copilot (Esqueleto)

Para generar el c√≥digo con GitHub Copilot, puedes seguir una estructura comentada que describa cada parte. Por ejemplo, en el archivo nav_Enriquecer.py, comenzar con un comentario largo que sintetice estos pasos, y luego ir implementando secci√≥n por secci√≥n. Un posible enfoque:

# nav_Enriquecer.py

# 1. Importar librer√≠as necesarias (streamlit, json, os, dotenv, requests, etc.)
# 2. Cargar configuraci√≥n desde .env (puntaje m√≠nimo, API keys)
# 3. Cargar datos de etapas 1 y 2 (por ejemplo, leer CSV/JSON con pandas o json module)
# 4. Filtrar dominios por puntaje m√≠nimo y preparar estructura de datos por dominio
# 5. Configurar interfaz de usuario con Streamlit:
#    - Mostrar t√≠tulo y descripci√≥n
#    - Campo de b√∫squeda para filtrar dominios/personas
#    - Lista (multiselect) de dominios aptos filtrados
#    - Bot√≥n para ejecutar enriquecimiento
# 6. Al hacer clic en "Enriquecer":
#    - Para cada dominio seleccionado:
#       a. Verificar si ya est√° procesado (en JSON log)
#       b. Obtener datos necesarios (nombre empresa, personas, etc.)
#       c. Consultar APIs de Lusha/RocketReach/ContactOut seg√∫n disponibilidad:
#           - Buscar personas con roles relevantes (marketing/eventos) usando dominio/empresa
#           - O buscar correos de personas espec√≠ficas si tenemos nombres
#       d. Recopilar resultados en estructura (lista de contactos)
#       e. A√±adir resultados al dict global enriquecidos_data
#       f. Loggear la operaci√≥n (en consola, Streamlit, y/o archivo log)
#    - Guardar enriquecidos_data a JSON (incremental)
#    - Mostrar resumen de resultados (ej. "Dominio X: 2 nuevos contactos a√±adidos")
#
# 7. Finalizar mostrando quiz√°s un enlace o bot√≥n para descargar el JSON de resultados, etc.

# ... (Luego iniciar a codificar seg√∫n este plan)


Siguiendo este plan detallado en comentarios, Copilot podr√° ayudarte a generar autom√°ticamente partes significativas del c√≥digo para cada secci√≥n. Aseg√∫rate de revisar y completar las llamadas a APIs espec√≠ficas con los formatos correctos (consultando la documentaci√≥n si es necesario) y probar el script para verificar que funciona correctamente con tus datos y credenciales.

¬°Con esta gu√≠a, tendr√°s un blueprint claro para implementar nav_Enriquecer.py usando Copilot de forma eficaz!